//
// Generated file, do not edit! Created by opp_msgc 4.1 from applications/dxps/DxpsMessage.msg.
//

#ifndef _DXPSMESSAGE_M_H_
#define _DXPSMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0401
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <CommonMessages_m.h>

class DxpsTimer;

#include "DxpsRoutingTable.h"


static const int DXPS_WRONGROOT_L = 8;
static const int DXPS_EMPTYFLAG_L = 8;



#define DXPS_JOINCALL_L(msg) (BASECALL_L(msg))
#define DXPS_JOINRESPONSE_L(msg) (BASECALL_L(msg))
#define DXPS_PUBLISHCALL_L(msg) (BASECALL_L(msg))
#define DXPS_PUBLISHRESPONSE_L(msg) (BASECALL_L(msg) + DXPS_WRONGROOT_L)

#define DXPS_SUBSCRIPTIONREFRESH_L(msg) (NODEHANDLE_L + KEY_L)
#define DXPS_LEAVE_L(msg) (NODEHANDLE_L + KEY_L)
#define DXPS_DATA_L(msg) (KEY_L + DXPS_EMPTYFLAG_L)
#define DXPS_SUBSCRIPTIONMESSAGE_L(msg) (KEY_L + DXPS_EMPTYFLAG_L)
// }}



/**
 * Enum generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum DxpsTimerType 
 * {
 * 
 *     DXPS_HEARTBEAT = 0; 
 *     DXPS_SUBSCRIPTION_REFRESH = 1; 
 *     DXPS_PARENT_TIMEOUT = 2; 
 *     DXPS_CHILD_TIMEOUT = 3; 
 * }
 * </pre>
 */
enum DxpsTimerType {
    DXPS_HEARTBEAT = 0,
    DXPS_SUBSCRIPTION_REFRESH = 1,
    DXPS_PARENT_TIMEOUT = 2,
    DXPS_CHILD_TIMEOUT = 3
};

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsJoinCall extends BaseCallMessage
 * {
 *         OverlayKey srcLogicalNodeKey;
 *         OverlayKey dstLogicalNodeKey;
 *                             
 * }
 * </pre>
 */
class DxpsJoinCall : public ::BaseCallMessage
{
  protected:
    ::OverlayKey srcLogicalNodeKey_var;
    ::OverlayKey dstLogicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsJoinCall&);

  public:
    DxpsJoinCall(const char *name=NULL, int kind=0);
    DxpsJoinCall(const DxpsJoinCall& other);
    virtual ~DxpsJoinCall();
    DxpsJoinCall& operator=(const DxpsJoinCall& other);
    virtual DxpsJoinCall *dup() const {return new DxpsJoinCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getSrcLogicalNodeKey();
    virtual const OverlayKey& getSrcLogicalNodeKey() const {return const_cast<DxpsJoinCall*>(this)->getSrcLogicalNodeKey();}
    virtual void setSrcLogicalNodeKey(const OverlayKey& srcLogicalNodeKey_var);
    virtual OverlayKey& getDstLogicalNodeKey();
    virtual const OverlayKey& getDstLogicalNodeKey() const {return const_cast<DxpsJoinCall*>(this)->getDstLogicalNodeKey();}
    virtual void setDstLogicalNodeKey(const OverlayKey& dstLogicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsJoinCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsJoinCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsSubCall extends BaseCallMessage 
 * {
 *         OverlayKey srcLogicalNodeKey;
 *         OverlayKey dstLogicalNodeKey;
 *                             
 * }
 * </pre>
 */
class DxpsSubCall : public ::BaseCallMessage
{
  protected:
    ::OverlayKey srcLogicalNodeKey_var;
    ::OverlayKey dstLogicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsSubCall&);

  public:
    DxpsSubCall(const char *name=NULL, int kind=0);
    DxpsSubCall(const DxpsSubCall& other);
    virtual ~DxpsSubCall();
    DxpsSubCall& operator=(const DxpsSubCall& other);
    virtual DxpsSubCall *dup() const {return new DxpsSubCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getSrcLogicalNodeKey();
    virtual const OverlayKey& getSrcLogicalNodeKey() const {return const_cast<DxpsSubCall*>(this)->getSrcLogicalNodeKey();}
    virtual void setSrcLogicalNodeKey(const OverlayKey& srcLogicalNodeKey_var);
    virtual OverlayKey& getDstLogicalNodeKey();
    virtual const OverlayKey& getDstLogicalNodeKey() const {return const_cast<DxpsSubCall*>(this)->getDstLogicalNodeKey();}
    virtual void setDstLogicalNodeKey(const OverlayKey& dstLogicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsSubCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsSubCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsJoinResponse extends BaseResponseMessage
 * {
 *         OverlayKey logicalNodeKey; 
 *                             
 * }
 * </pre>
 */
class DxpsJoinResponse : public ::BaseResponseMessage
{
  protected:
    ::OverlayKey logicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsJoinResponse&);

  public:
    DxpsJoinResponse(const char *name=NULL, int kind=0);
    DxpsJoinResponse(const DxpsJoinResponse& other);
    virtual ~DxpsJoinResponse();
    DxpsJoinResponse& operator=(const DxpsJoinResponse& other);
    virtual DxpsJoinResponse *dup() const {return new DxpsJoinResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsJoinResponse*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsJoinResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsJoinResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsSubResponse extends BaseResponseMessage
 * {
 *         OverlayKey logicalNodeKey; 
 *                             
 * }
 * </pre>
 */
class DxpsSubResponse : public ::BaseResponseMessage
{
  protected:
    ::OverlayKey logicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsSubResponse&);

  public:
    DxpsSubResponse(const char *name=NULL, int kind=0);
    DxpsSubResponse(const DxpsSubResponse& other);
    virtual ~DxpsSubResponse();
    DxpsSubResponse& operator=(const DxpsSubResponse& other);
    virtual DxpsSubResponse *dup() const {return new DxpsSubResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsSubResponse*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsSubResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsSubResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsPublishCall extends BaseCallMessage
 * {
 *         OverlayKey logicalNodeKey; 
 *                             
 * }
 * </pre>
 */
class DxpsPublishCall : public ::BaseCallMessage
{
  protected:
    ::OverlayKey logicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsPublishCall&);

  public:
    DxpsPublishCall(const char *name=NULL, int kind=0);
    DxpsPublishCall(const DxpsPublishCall& other);
    virtual ~DxpsPublishCall();
    DxpsPublishCall& operator=(const DxpsPublishCall& other);
    virtual DxpsPublishCall *dup() const {return new DxpsPublishCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsPublishCall*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsPublishCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsPublishCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsPublishResponse extends BaseResponseMessage
 * {
 *         OverlayKey logicalNodeKey; 
 *                             
 *         bool wrongRoot = false;
 * }
 * </pre>
 */
class DxpsPublishResponse : public ::BaseResponseMessage
{
  protected:
    ::OverlayKey logicalNodeKey_var;
    bool wrongRoot_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsPublishResponse&);

  public:
    DxpsPublishResponse(const char *name=NULL, int kind=0);
    DxpsPublishResponse(const DxpsPublishResponse& other);
    virtual ~DxpsPublishResponse();
    DxpsPublishResponse& operator=(const DxpsPublishResponse& other);
    virtual DxpsPublishResponse *dup() const {return new DxpsPublishResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsPublishResponse*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
    virtual bool getWrongRoot() const;
    virtual void setWrongRoot(bool wrongRoot_var);
};

inline void doPacking(cCommBuffer *b, DxpsPublishResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsPublishResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsSubscribeCall extends BaseCallMessage
 * {
 *         OverlayKey logicalNodeKey; 
 *                             
 * }
 * </pre>
 */
class DxpsSubscribeCall : public ::BaseCallMessage
{
  protected:
    ::OverlayKey logicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsSubscribeCall&);

  public:
    DxpsSubscribeCall(const char *name=NULL, int kind=0);
    DxpsSubscribeCall(const DxpsSubscribeCall& other);
    virtual ~DxpsSubscribeCall();
    DxpsSubscribeCall& operator=(const DxpsSubscribeCall& other);
    virtual DxpsSubscribeCall *dup() const {return new DxpsSubscribeCall(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsSubscribeCall*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsSubscribeCall& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsSubscribeCall& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsSubscribeResponse extends BaseResponseMessage
 * {
 *         OverlayKey logicalNodeKey; 
 *                             
 *         bool wrongRoot = false;
 * }
 * </pre>
 */
class DxpsSubscribeResponse : public ::BaseResponseMessage
{
  protected:
    ::OverlayKey logicalNodeKey_var;
    bool wrongRoot_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsSubscribeResponse&);

  public:
    DxpsSubscribeResponse(const char *name=NULL, int kind=0);
    DxpsSubscribeResponse(const DxpsSubscribeResponse& other);
    virtual ~DxpsSubscribeResponse();
    DxpsSubscribeResponse& operator=(const DxpsSubscribeResponse& other);
    virtual DxpsSubscribeResponse *dup() const {return new DxpsSubscribeResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsSubscribeResponse*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
    virtual bool getWrongRoot() const;
    virtual void setWrongRoot(bool wrongRoot_var);
};

inline void doPacking(cCommBuffer *b, DxpsSubscribeResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsSubscribeResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsSubscriptionRefreshMessage
 * {
 *         NodeHandle src;
 *         OverlayKey logicalNodeKey;
 * }
 * </pre>
 */
class DxpsSubscriptionRefreshMessage : public ::cPacket
{
  protected:
    ::NodeHandle src_var;
    ::OverlayKey logicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsSubscriptionRefreshMessage&);

  public:
    DxpsSubscriptionRefreshMessage(const char *name=NULL, int kind=0);
    DxpsSubscriptionRefreshMessage(const DxpsSubscriptionRefreshMessage& other);
    virtual ~DxpsSubscriptionRefreshMessage();
    DxpsSubscriptionRefreshMessage& operator=(const DxpsSubscriptionRefreshMessage& other);
    virtual DxpsSubscriptionRefreshMessage *dup() const {return new DxpsSubscriptionRefreshMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getSrc();
    virtual const NodeHandle& getSrc() const {return const_cast<DxpsSubscriptionRefreshMessage*>(this)->getSrc();}
    virtual void setSrc(const NodeHandle& src_var);
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsSubscriptionRefreshMessage*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsSubscriptionRefreshMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsSubscriptionRefreshMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsLeaveMessage
 * {
 *         NodeHandle src;
 *         OverlayKey logicalNodeKey;
 * }
 * </pre>
 */
class DxpsLeaveMessage : public ::cPacket
{
  protected:
    ::NodeHandle src_var;
    ::OverlayKey logicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsLeaveMessage&);

  public:
    DxpsLeaveMessage(const char *name=NULL, int kind=0);
    DxpsLeaveMessage(const DxpsLeaveMessage& other);
    virtual ~DxpsLeaveMessage();
    DxpsLeaveMessage& operator=(const DxpsLeaveMessage& other);
    virtual DxpsLeaveMessage *dup() const {return new DxpsLeaveMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual NodeHandle& getSrc();
    virtual const NodeHandle& getSrc() const {return const_cast<DxpsLeaveMessage*>(this)->getSrc();}
    virtual void setSrc(const NodeHandle& src_var);
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsLeaveMessage*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsLeaveMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsLeaveMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * message DxpsTimer
 * {
 *         int timerType enum(DxpsTimerType);
 *         NodeHandle child;
 *         OverlayKey logicalNodeKey;
 * }
 * </pre>
 */
class DxpsTimer : public ::cMessage
{
  protected:
    int timerType_var;
    ::NodeHandle child_var;
    ::OverlayKey logicalNodeKey_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsTimer&);

  public:
    DxpsTimer(const char *name=NULL, int kind=0);
    DxpsTimer(const DxpsTimer& other);
    virtual ~DxpsTimer();
    DxpsTimer& operator=(const DxpsTimer& other);
    virtual DxpsTimer *dup() const {return new DxpsTimer(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getTimerType() const;
    virtual void setTimerType(int timerType_var);
    virtual NodeHandle& getChild();
    virtual const NodeHandle& getChild() const {return const_cast<DxpsTimer*>(this)->getChild();}
    virtual void setChild(const NodeHandle& child_var);
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsTimer*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
};

inline void doPacking(cCommBuffer *b, DxpsTimer& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsDataMessage
 * {
 *         OverlayKey logicalNodeKey;
 *         long dxpsMsgId =0;
 *         bool empty = false;
 * }
 * </pre>
 */
class DxpsDataMessage : public ::cPacket
{
  protected:
    ::OverlayKey logicalNodeKey_var;
    long dxpsMsgId_var;
    bool empty_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsDataMessage&);

  public:
    DxpsDataMessage(const char *name=NULL, int kind=0);
    DxpsDataMessage(const DxpsDataMessage& other);
    virtual ~DxpsDataMessage();
    DxpsDataMessage& operator=(const DxpsDataMessage& other);
    virtual DxpsDataMessage *dup() const {return new DxpsDataMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsDataMessage*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
    virtual long getDxpsMsgId() const;
    virtual void setDxpsMsgId(long dxpsMsgId_var);
    virtual bool getEmpty() const;
    virtual void setEmpty(bool empty_var);
};

inline void doPacking(cCommBuffer *b, DxpsDataMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsDataMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsDataDeliverMessage
 * {
 *         OverlayKey logicalNodeKey;
 *         long dxpsMsgId =0;
 *         bool empty = false;
 * }
 * </pre>
 */
class DxpsDataDeliverMessage : public ::cPacket
{
  protected:
    ::OverlayKey logicalNodeKey_var;
    long dxpsMsgId_var;
    bool empty_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsDataDeliverMessage&);

  public:
    DxpsDataDeliverMessage(const char *name=NULL, int kind=0);
    DxpsDataDeliverMessage(const DxpsDataDeliverMessage& other);
    virtual ~DxpsDataDeliverMessage();
    DxpsDataDeliverMessage& operator=(const DxpsDataDeliverMessage& other);
    virtual DxpsDataDeliverMessage *dup() const {return new DxpsDataDeliverMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsDataDeliverMessage*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
    virtual long getDxpsMsgId() const;
    virtual void setDxpsMsgId(long dxpsMsgId_var);
    virtual bool getEmpty() const;
    virtual void setEmpty(bool empty_var);
};

inline void doPacking(cCommBuffer *b, DxpsDataDeliverMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsDataDeliverMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/dxps/DxpsMessage.msg</tt> by opp_msgc.
 * <pre>
 * packet DxpsSubscriptionMessage
 * {
 *         OverlayKey logicalNodeKey;
 *         long dxpsMsgId =0;
 *         bool empty = false;
 * }
 * </pre>
 */
class DxpsSubscriptionMessage : public ::cPacket
{
  protected:
    ::OverlayKey logicalNodeKey_var;
    long dxpsMsgId_var;
    bool empty_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DxpsSubscriptionMessage&);

  public:
    DxpsSubscriptionMessage(const char *name=NULL, int kind=0);
    DxpsSubscriptionMessage(const DxpsSubscriptionMessage& other);
    virtual ~DxpsSubscriptionMessage();
    DxpsSubscriptionMessage& operator=(const DxpsSubscriptionMessage& other);
    virtual DxpsSubscriptionMessage *dup() const {return new DxpsSubscriptionMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual OverlayKey& getLogicalNodeKey();
    virtual const OverlayKey& getLogicalNodeKey() const {return const_cast<DxpsSubscriptionMessage*>(this)->getLogicalNodeKey();}
    virtual void setLogicalNodeKey(const OverlayKey& logicalNodeKey_var);
    virtual long getDxpsMsgId() const;
    virtual void setDxpsMsgId(long dxpsMsgId_var);
    virtual bool getEmpty() const;
    virtual void setEmpty(bool empty_var);
};

inline void doPacking(cCommBuffer *b, DxpsSubscriptionMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DxpsSubscriptionMessage& obj) {obj.parsimUnpack(b);}


#endif // _DXPSMESSAGE_M_H_
